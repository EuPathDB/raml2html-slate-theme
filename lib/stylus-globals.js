'use strict'

/**
 * Ensure a string is safe to use as a html id attribute
 * @param  {string} id The potentially unsafe id string
 * @return {string}    The safe id string
 */
function getSafeId (id) {
  if (id === undefined) id = ''
  return id.toLowerCase().replace(' ', '-')
}

/**
 * Check whether the given array contains an element with an
 * examples attribute
 * @param {array<object>} data An array of RAML nodes (methods, parameters)
 * @return {boolean}
 */
function hasExamples (data) {
  if (!Array.isArray(data)) return false
  return data.reduce((current, item) => current || (Boolean(item.examples) && item.examples.length > 0), false)
}

/**
 * Get all unique response headers of a method
 * Only the first instance of a header will be returned
 * @param  {object} method A method object as found in a parsed RAML file
 * @return {array}         An array of header objects
 */
function getResponseHeaders (method) {
  if (!method || !method.responses) return []
  return method.responses
    .map((resp) => resp.headers ? resp.headers : [])
    .reduce((current, resp) => current.concat(resp), [])
    .filter((header, index, array) => array.findIndex((item) => item.key === header.key) === index)
}

/**
 * TODO add tests
 * Generate a cURL statement for a method on a resource
 * @param  {string} baseUri  The baseUri of the API (if any)
 * @param  {object} method   A method object as generated by RAML
 * @param  {object} resource A resource object as generated by RAML
 * @param  {object} security A securitySchemes object as generated by RAML 
 * @return {string}          A example curl statement that calls the API
 */
function getCurlStatement (baseUri, method, resource, security) {
  baseUri = baseUri || ''
  if (baseUri.endsWith('/')) baseUri = baseUri.slice(0, -1)
  method.headers = method.headers || []
  method.queryParameters = method.queryParameters || []
  method.method = method.method || 'get'

  const payload = ['patch', 'post', 'put'].includes(method.method) ? ' \\\n\t-d @request_body' : ''
  const parentUrl = resource.parentUrl || ''
  const relativeUri = resource.relativeUri || '/'

  const headers = method.headers
    .filter((header) => header.examples && header.examples.length !== 0)
    .map((header) => ` \\\n\t-H "${header.key}: ${header.examples[0].value}"`).join('')

  let params = method.queryParameters
    .filter((param) => param.examples && param.examples.length !== 0)
    .map((param) => `${param.key}=${param.examples[0].value}`)
    .join('&')
  params = params === '' ? '' : `?${params}`

  const curlAuthCommands = {
    'Basic Authentication': curlBasicAuth,
    'Digest Authentication': curlDigestAuth,
    'x-custom': curlXCustomAuth
  }
  let auth = ''
  if (method.securedBy && security) {
    const scheme = security[method.securedBy[0].schemeName]
    let command = curlAuthCommands[scheme.type]
    if (scheme && command) {
      auth = command(scheme)
    }
  }

  return `curl -X ${method.method.toUpperCase()} "${baseUri}${parentUrl}${relativeUri}${params}"${headers}${payload}${auth}`
}

/**
 * Return a string to append to a curl command for Basic Authentication
 * @return {string} String to append to the curl command with the apropriate headers
 */
function curlBasicAuth () {
  return ' \\\n\t--user username:password'
}

/**
 * Return a string to append to a curl command for Digest Authentication
 * @return {string} String to append to the curl command with the apropriate headers
 */
function curlDigestAuth () {
  return ' \\\n\t--user username:password --digest'
}

/**
 * Return a string that represents the headers to send with a curl command
 * @param  {object} scheme A Security Scheme object as generated by RAML 
 * @return {string}        String to append to the curl command with the apropriate headers
 */
function curlXCustomAuth (scheme) {
  return scheme.describedBy.headers
    .map((header) => ` \\\n\t-H "${header.name}: ${header.type}"`)
    .join('')
}

/**
 * Return a short string for use in the language tabs based on the input mime type
 * @param  {string} mime A mime type
 * @return {string}      A short version of the mime type we can use in a css classname
 */
function getLanguage (mime) {
  if (/json/.test(mime)) {
    return 'json'
  } else if (/xml/.test(mime)) {
    return 'xml'
  } else if (mime === 'text/event-stream') {
    return 'sse'
  } else {
    return ''
  }
}

/**
 * Parses a ramlObj and returns an object containing the top level type definitions
 * Takes care of the differences between the legacy `schemas` and new `types` attributes
 * return the same structure regardless of which attributes are used in the input
 * @this  {object} The nunjucks global, which has a ctx (context) attribute that is the current ramlObj
 * @return {array} An array containing the top level schemas with some meta data
 */
function getTypeDefinitions () {
  const ramlObj = this.ctx || {}
  // The new `types` property is prefered
  if (ramlObj.types) {
    return Object.keys(ramlObj.types)
      .map((item) => ramlObj.types[item])
      .map((item) => item.typePropertyKind === 'TYPE_EXPRESSION'
        ? typeToJson(item)
        : item
      )
  }
  if (ramlObj.schemas) {
    return ramlObj.schemas
      .map((item) => item[Object.keys(item)[0]])
      .map((item) => {
        if (item.typePropertyKind === 'TYPE_EXPRESSION') return typeToJson(item)
        item.content = item.type
        item.type = 'json'
        return item
      })
  }
  return []
}

/**
 * Convert a TYPE_EXPRESSION into a shape that resembles a JSON schema
 * @param  {object} type A TYPE_EXPRESSION from a raml type or schema
 * @return {object}      A TYPE_EXPRESSION enriched with a json schema-like key
 */
function typeToJson (type) {
  let content = JSON.stringify({
    name: type.name,
    type: type.type,
    description: type.description,
    properties: type.properties
  }, null, 2)
  type.content = content
  return type
}

/**
 * Test whether the current ramlObject has a type specified
 * Accounts for depecrated schema and new type attributes
 * @param  {object}  item A raml item
 * @return {Boolean}
 */
function hasType (item) {
  item = item || {}
  return Boolean(item.type) || Boolean(item.schema)
}

/**
 * Returns the type property from a ramlObject
 * Accounts for depecrated schema and new type atttributes. A type is prefered
 * over a schema
 * Will return a common structure regardless of the input
 * @param  {object} item A ramlObject with an associated schema or type
 * @return {object}      The schema or type
 */
function getType (item) {
  item = item || {}
  let output = item.type || item.schema
  if (!output) return ''
  if (Array.isArray(output)) output = output[0]
  if (typeof output !== 'string') output = JSON.stringify(output, null, 2)
  return output
}

module.exports = {
  getCurlStatement,
  getLanguage,
  getResponseHeaders,
  getSafeId,
  hasExamples,
  getTypeDefinitions,
  hasType,
  getType
}
