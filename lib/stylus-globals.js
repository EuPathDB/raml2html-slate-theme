'use strict'

/**
 * Ensure a string is safe to use as a html id attribute
 * @param  {string} id The potentially unsafe id string
 * @return {string}    The safe id string
 */
function getSafeId (id) {
  if (id === undefined) id = ''
  return id.toLowerCase().replace(' ', '-')
}

/**
 * Check whether the given array contains an element with an
 * examples attribute
 * @param {array<object>} data An array of RAML nodes (methods, parameters)
 * @return {boolean}
 */
function hasExamples (data) {
  if (!Array.isArray(data)) return false
  return data.reduce((current, item) => current || (Boolean(item.examples) && item.examples.length > 0), false)
}

/**
 * Get all unique response headers of a method
 * Only the first instance of a header will be returned
 * @param  {object} method A method object as found in a parsed RAML file
 * @return {array}         An array of header objects
 */
function getResponseHeaders (method) {
  if (!method || !method.responses) return []
  return method.responses
    .map((resp) => resp.headers ? resp.headers : [])
    .reduce((current, resp) => current.concat(resp), [])
    .filter((header, index, array) => array.findIndex((item) => item.key === header.key) === index)
}

/**
 * TODO add tests
 * Generate a cURL statement for a method on a resource
 * @param  {string} baseUri  The baseUri of the API (if any)
 * @param  {object} method   A method object as generated by RAML
 * @param  {object} resource A resource object as generated by RAML
 * @param  {object} security A securitySchemes object as generated by RAML 
 * @return {string}          A example curl statement that calls the API
 */
function getCurlStatement (baseUri, method, resource, security) {
  baseUri = baseUri || ''
  if (baseUri.endsWith('/')) baseUri = baseUri.slice(0, -1)
  method.headers = method.headers || []
  method.queryParameters = method.queryParameters || []
  method.method = method.method || 'get'

  const payload = ['patch', 'post', 'put'].includes(method.method) ? ' \\\n\t-d @request_body' : ''
  const parentUrl = resource.parentUrl || ''
  const relativeUri = resource.relativeUri || '/'

  let headers = method.headers
    .filter((header) => header.examples && header.examples.length !== 0)
    .map((header) => ` \\\n\t-H "${header.key}: ${header.examples[0].value}"`)

  let params = method.queryParameters
    .filter((param) => param.examples && param.examples.length !== 0)
    .map((param) => `${param.key}=${param.examples[0].value}`)

  const resourceOptions = {
    method: method.method,
    baseUri: baseUri,
    path: `${parentUrl}${relativeUri}`,
    params: params,
    headers: headers,
    payload: payload
  }

  const commands = []
  if (security && method.securedBy) {
    method.securedBy.forEach((methodScheme) => {
      if (methodScheme) {
        let securityScheme = security[methodScheme.schemeName]
        if (securityScheme) {
          Array.prototype.push.apply(commands, buildCurlCommands(resourceOptions, securityScheme))
        }
      } else {
        Array.prototype.push.apply(commands, buildCurlCommands(resourceOptions, {type: 'null'}))
      }
    })
  } else {
    Array.prototype.push.apply(commands, buildCurlCommands(resourceOptions, {type: 'null'}))
  }

  return commands.join('\n\n or \n\n')
}

/**
 * Builds one or more curl commands for a method and set of security schemes
 * @param  {object}   methodParams         The set of parameters describing a methof
 * @param  {string}   methodParams.method  The HTTP method
 * @param  {string}   methodParams.baseUri The base URI
 * @param  {string}   methodParams.path    The path
 * @param  {String[]} methodParams.params  An array of serialized key-value pairs that make up the query string parameters
 * @param  {String[]} methodParams.headers An array of sewrialized HTTP headers
 * @param  {*}        methodParams.payload The payload to send in the request
 * @param  {object}   securityScheme       A Security Scheme object as generated by RAML
 * @return {String[]}                      An array of strings that represents the possible curl commands
 */
function buildCurlCommands (methodParams, securityScheme) {
  const curlAuthFunctions = {
    'Basic Authentication': curlBasicAuth,
    'Digest Authentication': curlDigestAuth,
    'x-custom': curlXCustomAuth,
    'OAuth 2.0': curlOAuth2,
    'null': curlNullAuth
  }

  const authFunction = curlAuthFunctions[securityScheme.type]
  const curlCommands = authFunction(securityScheme).map((curlProps) => {
    let params = methodParams.params.slice()
    if (curlProps.params) { Array.prototype.push.apply(params, curlProps.params) }
    params = params.join('&')
    params = params === '' ? '' : `?${params}`

    let headers = methodParams.headers.slice()
    if (curlProps.headers) { Array.prototype.push.apply(headers, curlProps.headers) }
    headers = headers.join('')

    let options = ''
    if (curlProps.options) { options = curlProps.options }

    return `curl -X ${methodParams.method.toUpperCase()} "${methodParams.baseUri}${methodParams.path}${params}"${headers}${methodParams.payload}${options}`
  })

  return curlCommands
}

/**
 * Handler for applying options for null auth
 * @return {Object[]} An array of 1 empty object, as no options should apply
 */
function curlNullAuth () {
  return [{}]
}

/**
 * Handler for applying options for HTTP Basic auth
 * @return {Object[]} An array of 1 object with the curl options for HTTP Basic auth
 */
function curlBasicAuth () {
  return [{ options: ' \\\n\t--user username:password' }]
}

/**
 * Handler for applying options for HTTP Digest auth
 * @return {Object[]} An array of 1 object with the curl options for HTTP Digest auth
 */
function curlDigestAuth () {
  return [{ options: ' \\\n\t--user username:password --digest' }]
}

/**
 * Handler for applying options for Custom auth
 * @param  {object}   Security Scheme object as generate by RAML
 * @return {Object[]} An array of 1 object with the additional headers for the custom auth as described by the security scheme
 */
function curlXCustomAuth (securityScheme) {
  return [{
    headers: securityScheme.describedBy.headers.map((header) => ` \\\n\t-H "${header.name}: ${header.type}"`)
  }]
}

/**
 * Handler for applying options for OAuth2 auth
 * @param  {object}   Security Scheme object as generate by RAML
 * @return {Object[]} An array of 2 objects, one containing the headers, the other, query string parameters, for the OAuth 2 auth as described by the security scheme
 */
function curlOAuth2 (scheme) {
  let header = scheme.describedBy.headers[0]
  let query = scheme.describedBy.queryParameters[0]
  return [
    {
      headers: [` \\\n\t-H "${header.name}: Bearer ${header.type}"`]
    },
    {
      params: [`${query.name}=${query.type}`]
    }
  ]
}

/**
 * Return a short string for use in the language tabs based on the input mime type
 * @param  {string} mime A mime type
 * @return {string}      A short version of the mime type we can use in a css classname
 */
function getLanguage (mime) {
  if (/json/.test(mime)) {
    return 'json'
  } else if (/xml/.test(mime)) {
    return 'xml'
  } else if (mime === 'text/event-stream') {
    return 'sse'
  } else {
    return ''
  }
}

/**
 * Parses a ramlObj and returns an object containing the top level type definitions
 * Takes care of the differences between the legacy `schemas` and new `types` attributes
 * return the same structure regardless of which attributes are used in the input
 * @this  {object} The nunjucks global, which has a ctx (context) attribute that is the current ramlObj
 * @return {array} An array containing the top level schemas with some meta data
 */
function getTypeDefinitions () {
  const ramlObj = this.ctx || {}
  // The new `types` property is prefered
  if (ramlObj.types) {
    return Object.keys(ramlObj.types)
      .map((item) => ramlObj.types[item])
      .map((item) => item.typePropertyKind === 'TYPE_EXPRESSION'
        ? typeToJson(item)
        : item
      )
  }
  if (ramlObj.schemas) {
    return ramlObj.schemas
      .map((item) => item[Object.keys(item)[0]])
      .map((item) => {
        if (item.typePropertyKind === 'TYPE_EXPRESSION') return typeToJson(item)
        item.content = item.type
        item.type = 'json'
        return item
      })
  }
  return []
}

/**
 * Convert a TYPE_EXPRESSION into a shape that resembles a JSON schema
 * @param  {object} type A TYPE_EXPRESSION from a raml type or schema
 * @return {object}      A TYPE_EXPRESSION enriched with a json schema-like key
 */
function typeToJson (type) {
  let content = JSON.stringify({
    name: type.name,
    type: type.type,
    description: type.description,
    properties: type.properties
  }, null, 2)
  type.content = content
  return type
}

/**
 * Test whether the current ramlObject has a type specified
 * Accounts for depecrated schema and new type attributes
 * @param  {object}  item A raml item
 * @return {Boolean}
 */
function hasType (item) {
  item = item || {}
  return Boolean(item.type) || Boolean(item.schema)
}

/**
 * Returns the type property from a ramlObject
 * Accounts for depecrated schema and new type atttributes. A type is prefered
 * over a schema
 * Will return a common structure regardless of the input
 * @param  {object} item A ramlObject with an associated schema or type
 * @return {object}      The schema or type
 */
function getType (item) {
  item = item || {}
  let output = item.type || item.schema
  if (!output) return ''
  if (Array.isArray(output)) output = output[0]
  if (typeof output !== 'string') output = JSON.stringify(output, null, 2)
  return output
}

module.exports = {
  getCurlStatement,
  getLanguage,
  getResponseHeaders,
  getSafeId,
  hasExamples,
  getTypeDefinitions,
  hasType,
  getType
}
