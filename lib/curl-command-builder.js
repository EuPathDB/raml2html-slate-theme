'use strict'

/**
 * Builds an array of curl commands for the given method and security schemes
 * @param  {object}        methodParams           The set of parameters describing a methof
 * @param  {string}        methodParams.method    The HTTP method
 * @param  {string}        methodParams.baseUri   The base URI
 * @param  {string}        methodParams.path      The path
 * @param  {array<string>} methodParams.params    An array of serialized key-value pairs that make up the query string parameters
 * @param  {array<string>} methodParams.headers   An array of sewrialized HTTP headers
 * @param  {*}             methodParams.payload   The payload to send in the request
 * @param  {array<object>} methodParams.securedBy An array of security references from the RAML
 * @param  {object}        securitySchemes        A hash of Security Scheme objects as generated by RAML
 * @return {array<string>}
 */
function forMethod (methodParams, securitySchemes) {
  let commands = []
  if (securitySchemes && methodParams.securedBy) {
    commands = securedCommands(methodParams, securitySchemes)
  }
  if (commands.length === 0) {
    commands = unsecuredCommands(methodParams)
  }
  return commands
}

/**
 * Builds a curl command string without security
 * @param {object} methodParams See definition in forMethod
 */
function unsecuredCommands (methodParams) {
  return buildCurlCommands(methodParams)
}

/**
 * Builds curl commands with security schemes
 * @param {object} methodParams     See definition in forMethod
 * @param {object} securitySchemes  A hash of Security Scheme objects as generated by RAML
 * @return {array<string>}
 */
function securedCommands (methodParams, securitySchemes) {
  let commands = []
  methodParams.securedBy.forEach((methodScheme) => {
    if (methodScheme) {
      let securityScheme = securitySchemes[methodScheme.schemeName]
      if (securityScheme) {
        commands = commands.concat(buildCurlCommands(methodParams, securityScheme))
      }
    } else {
      commands = unsecuredCommands(methodParams)
    }
  })
  return commands
}

/**
 * Builds one or more curl commands for a method and set of security schemes
 * @param  {object}        methodParams         The set of parameters describing a methof
 * @param  {string}        methodParams.method  The HTTP method
 * @param  {string}        methodParams.baseUri The base URI
 * @param  {string}        methodParams.path    The path
 * @param  {array<string>} methodParams.params  An array of serialized key-value pairs that make up the query string parameters
 * @param  {array<string>} methodParams.headers An array of sewrialized HTTP headers
 * @param  {*}             methodParams.payload The payload to send in the request
 * @param  {object}        securityScheme       A Security Scheme object as generated by RAML
 * @return {array<string>}                      An array of strings that represents the possible curl commands
 */
function buildCurlCommands (methodParams, securityScheme = {type: 'null'}) {
  const curlAuthFunctions = {
    'Basic Authentication': curlBasicAuth,
    'Digest Authentication': curlDigestAuth,
    'Pass Through': curlPassThroughAuth,
    'x-custom': curlXCustomAuth,
    'OAuth 1.0': curlOAuth1,
    'OAuth 2.0': curlOAuth2,
    'null': curlNullAuth
  }

  const authFunction = curlAuthFunctions[securityScheme.type] || curlNullAuth

  const curlCommands = authFunction(securityScheme).map((curlProps) => {
    let params = methodParams.params.slice()
    if (curlProps.params) { Array.prototype.push.apply(params, curlProps.params) }
    params = params.join('&')
    params = params === '' ? '' : `?${params}`

    let headers = methodParams.headers.slice()
    if (curlProps.headers) { Array.prototype.push.apply(headers, curlProps.headers) }
    headers = headers.join('')

    let options = ''
    if (curlProps.options) { options = curlProps.options }

    return `curl -X ${methodParams.method.toUpperCase()} "${methodParams.baseUri}${methodParams.path}${params}"${headers}${methodParams.payload}${options}`
  })

  return curlCommands
}

/**
 * Handler for applying options for null auth
 * @return {Object[]} An array of 1 empty object, as no options should apply
 */
function curlNullAuth () {
  return [{}]
}

/**
 * Handler for applying options for HTTP Basic auth
 * @return {Object[]} An array of 1 object with the curl options for HTTP Basic auth
 */
function curlBasicAuth () {
  return [{ options: ' \\\n\t--user username:password' }]
}

/**
 * Handler for applying options for HTTP Digest auth
 * @return {Object[]} An array of 1 object with the curl options for HTTP Digest auth
 */
function curlDigestAuth () {
  return [{ options: ' \\\n\t--user username:password --digest' }]
}

/**
 * Handler for applying options for Pass Through auth
 * 
 * Per the RAML 1.0 Spec:
 * You MUST provide a value for every header or queryParameter defined in describedBy and passed along with the request without modification.
 * @return {Object[]} An array of 1 object with the headers and query params for Pass Through auth
 */
function curlPassThroughAuth (securityScheme) {
  return [
    {
      headers: securityScheme.describedBy.headers.map((header) => ` \\\n\t-H "${header.name}: ${header.type}"`),
      params: securityScheme.describedBy.queryParameters.map((query) => `${query.name}=${query.type}`)
    }
  ]
}

/**
 * Handler for applying options for Custom auth
 * @param  {object}   Security Scheme object as generate by RAML
 * @return {Object[]} An array of 1 object with the additional headers for the custom auth as described by the security scheme
 */
function curlXCustomAuth (securityScheme) {
  return [{
    headers: securityScheme.describedBy.headers.map((header) => ` \\\n\t-H "${header.name}: ${header.type}"`)
  }]
}

/**
 * Handler for applying options for OAuth1 auth
 * @param  {object}   Security Scheme object as generate by RAML
 * @return {Object[]} An array of 2 objects, one containing the headers, the other, query string parameters, for the OAuth 1 auth
 */
function curlOAuth1 (scheme) {
  let signatureMethod = 'HMAC-SHA1'
  if (scheme.settings && scheme.settings.signatures) {
    signatureMethod = scheme.settings.signatures[0]
  }

  const parameters = {
    oauth_consumer_key: 'consumer_key',
    oauth_token: 'token',
    oauth_signature_method: signatureMethod,
    oauth_signature: 'computed_signature',
    oauth_timestamp: 'timestamp',
    oauth_nonce: 'nonce',
    oauth_version: '1.0'
  }

  const headerParams = Object
    .keys(parameters)
    .map(key => `${encodeURIComponent(key)}="${encodeURIComponent(parameters[key])}"`)
    .join(',\\\n\t')
  const queryStringParams = Object
    .keys(parameters)
    .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(parameters[key])}`)

  return [
    {
      headers: [` \\\n\t-H 'Authorization: OAuth realm="API",\\\n\t${headerParams}'`]
    },
    {
      params: queryStringParams
    }
  ]
}

/**
 * Handler for applying options for OAuth2 auth
 * @param  {object}   Security Scheme object as generate by RAML
 * @return {Object[]} An array of 2 objects, one containing the headers, the other, query string parameters, for the OAuth 2 auth as described by the security scheme
 */
function curlOAuth2 (scheme) {
  let header = scheme.describedBy.headers[0]
  let query = scheme.describedBy.queryParameters[0]
  return [
    {
      headers: [` \\\n\t-H "${header.name}: Bearer ${header.type}"`]
    },
    {
      params: [`${query.name}=${query.type}`]
    }
  ]
}

module.exports = {
  forMethod
}
