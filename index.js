'use strict'
let fs = require('fs')
const path = require('path')
const markdown = require('nunjucks-markdown')
const marked = require('marked')
const Minimize = require('minimize')
const nunjucks = require('nunjucks')
const stylus = require('stylus')

let minimize = new Minimize({quotes: true})
const templatesPath = path.join(__dirname, 'templates')
const DEFAULT_LOGO = path.join(templatesPath, 'images', 'logo.png')
const DEFAULT_COLOR_THEME = path.join(templatesPath, 'css', '_variables.styl.default')
const languageTabs = ['response', 'body']

/**
 * Renders a parsed RAML object into the templatesPath
 * @param  {object}          ramlObj A parsed RAML object as produced by raml2obj
 * @param  {object}          config  A map with raml2html configuration
 *                                   (create a typedef for this and validate)
 * @return {Promise<string>}         A Promise resolving to html as a string
 */
function processRamlObj (ramlObj, config) {
  return Promise.all([
    renderCss(templatesPath, config.colorThemePath),
    loadLogo(config.logoPath)
  ])
    .then((data) => {
      ramlObj.css = data[0]
      ramlObj.logo = data[1]
      ramlObj.logoMime = getMimeType(config.logoPath)
      ramlObj.languageTabs = languageTabs
      ramlObj.search = true

      return renderHtml(templatesPath, ramlObj)
    })
}

/**
 * Renders the stylus sheets along with the supplied theme into a css string
 * @param  {string}          basePath       The folder in which stylus references are resolved
 * @param  {string}          colorThemePath The path to _variables.styl
 * @return {Promise<string>}                A Promise resolving to the css stylesheet as a string
 */
function renderCss (basePath, colorThemePath) {
  // TODO: figure out how we can get load this from user config options
  const stylusPath = path.join(basePath, 'css', 'style.styl')
  return Promise.all([readFile(colorThemePath), readFile(stylusPath)])
    .then((stylusFiles) => {
      return new Promise((resolve, reject) => {
        stylus.render(
          stylusFiles.map((item) => item.toString('utf8')).join(''),
          {paths: [path.join(basePath, 'css')]},
          (err, css) => err ? reject(err) : resolve(css)
        )
      })
    })
}

/**
 * Read the logo at logoPath and return the contents as a base64 encoded string
 * @param  {string}          logoPath The path of the logo
 * @return {Promise<string>}          A Promise resolving to the base64 encoded content of the logo
 */
function loadLogo (logoPath) {
  return readFile(logoPath).then((buffer) => buffer.toString('base64'))
}

/**
 * Render the ramlObj into the nunjucks template and return the resulting
 * HTML as a string
 * @param  {string} basePath The directory in which nunjucks references are resolved
 * @param  {object} ramlObj  A ramlObj with some additional properties for logo and css
 * @return {string}          The final HTML
 */
function renderHtml (basePath, ramlObj) {
  const template = path.join(basePath, 'root.nunjucks')
  const env = nunjucks.configure(basePath, {autoescape: false})
  markdown.register(env, marked)
  return env.render(template, ramlObj)
}

/**
 * Guess the MIME type of a file based on extension. Uses `image/png` by default
 * @param  {string} filePath Path of the filePath
 * @return {string}          The MIME type of the file
 */
function getMimeType (filePath) {
  const pathInfo = path.parse(filePath)
  switch (pathInfo.ext.toLowerCase()) {
    case '.bmp':
      return 'image/bmp'
    case '.svg':
      return 'image/svg+xml'
    case '.tiff':
      return 'image/tiff'
    case '.jpg':
    case '.jpeg':
      return 'image/jpeg'
    case '.gif':
      return 'image/gif'
    case '.png':
    default:
      return 'image/png'
  }
}

/**
 * Promisified version of fs.readFile
 * @param  {string}          path The path of the file to readFile
 * @return {Promise<Buffer>}      A Promise resolving to a buffer with the file content
 */
function readFile (path) {
  return new Promise((resolve, reject) => {
    fs.readFile(path, (err, content) => err ? reject(err) : resolve(content))
  })
}

/**
 * Minimize the HTML
 * @param  {string}          data The HTML generated by the theme
 * @return {Promise<string>}      A Promise resolving to the minimized HTML
 */
function postProcessHtml (data) {
  return new Promise((resolve, reject) => {
    minimize.parse(data, (err, html) => err ? reject(err) : resolve(html))
  })
}

function configureTheme (args) {
  args = args || {}
  if (args['generate-color-theme']) {
    let defaultTheme = fs.readFileSync(DEFAULT_COLOR_THEME, {encoding: 'utf8'})
    fs.writeSync(1, defaultTheme)
    fs.fsyncSync(1)
    process.exit(0)
    return
  }

  const logoPath = args['logo'] || DEFAULT_LOGO
  const colorThemePath = args['color-theme'] || DEFAULT_COLOR_THEME

  return {
    colorThemePath,
    logoPath,
    processRamlObj,
    postProcessHtml
  }
}

module.exports = configureTheme
